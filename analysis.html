<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Attendance Analysis Suite</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: radial-gradient(circle at top left, rgba(37, 99, 235, 0.08), transparent 55%),
             radial-gradient(circle at bottom right, rgba(15, 23, 42, 0.08), transparent 60%),
             #f4f6fb;
      --surface: rgba(255, 255, 255, 0.96);
      --surface-soft: rgba(248, 250, 255, 0.86);
      --border: rgba(15, 23, 42, 0.08);
      --border-strong: rgba(15, 23, 42, 0.16);
      --text: #0f172a;
      --muted: #475467;
      --primary: #2563eb;
      --primary-soft: rgba(37, 99, 235, 0.12);
      --accent: #22c55e;
      --danger: #dc2626;
      --warning: #f97316;
      font-family: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--text);
      padding: clamp(24px, 5vw, 48px);
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    .shell {
      width: min(1200px, 100%);
      display: grid;
      gap: clamp(22px, 3vw, 36px);
    }
    .header {
      background: var(--surface);
      border-radius: 28px;
      border: 1px solid var(--border);
      box-shadow: 0 26px 52px rgba(15, 23, 42, 0.12);
      padding: clamp(28px, 4vw, 44px);
      display: grid;
      gap: 16px;
    }
    .brand {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      border-radius: 999px;
      background: var(--primary-soft);
      color: var(--primary);
      font-weight: 700;
      letter-spacing: 0.45px;
      text-transform: uppercase;
      font-size: 14px;
    }
    .brand::before {
      content: '';
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: linear-gradient(135deg, #0ea5e9, #2563eb);
      box-shadow: 0 0 10px rgba(37, 99, 235, 0.4);
    }
    h1 {
      margin: 0;
      font-size: clamp(34px, 6vw, 44px);
      letter-spacing: -0.6px;
    }
    .subhead {
      margin: 0;
      color: var(--muted);
      font-size: 17px;
      max-width: 70ch;
    }
    .data-bar {
      background: var(--surface);
      border-radius: 24px;
      border: 1px solid var(--border);
      box-shadow: 0 24px 48px rgba(15, 23, 42, 0.1);
      padding: clamp(22px, 3vw, 32px);
      display: grid;
      gap: 18px;
    }
    .data-flex {
      display: flex;
      flex-wrap: wrap;
      gap: 22px;
      align-items: flex-start;
    }
    .data-inputs {
      min-width: 260px;
      flex: 1 1 320px;
      display: grid;
      gap: 14px;
    }
    .data-inputs label {
      display: grid;
      gap: 6px;
      font-size: 13px;
      font-weight: 600;
      color: var(--muted);
    }
    .data-inputs input[type="file"],
    .data-inputs input[type="text"] {
      border-radius: 14px;
      border: 1px solid var(--border-strong);
      padding: 10px 14px;
      font-size: 14px;
      background: #fff;
      color: var(--text);
    }
    .data-inputs input[type="text"]:focus {
      outline: none;
      border-color: rgba(37, 99, 235, 0.6);
      box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.14);
    }
    .action-inline {
      display: inline-flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    .ghost-btn {
      border: 1px solid rgba(15, 23, 42, 0.12);
      border-radius: 12px;
      padding: 8px 14px;
      font-size: 13px;
      background: rgba(255, 255, 255, 0.92);
      color: var(--muted);
      cursor: pointer;
      transition: border 0.2s ease, color 0.2s ease;
    }
    .ghost-btn:hover {
      border-color: rgba(15, 23, 42, 0.24);
      color: var(--text);
    }
    .primary-btn {
      border: none;
      border-radius: 14px;
      padding: 12px 20px;
      font-size: 15px;
      font-weight: 600;
      background: linear-gradient(135deg, #15803d, #22c55e);
      color: #fff;
      box-shadow: 0 12px 24px rgba(21, 128, 61, 0.28);
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.2s ease, opacity 0.2s ease;
    }
    .primary-btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      box-shadow: none;
    }
    .data-stats {
      flex: 1 1 280px;
      display: grid;
      gap: 12px;
    }
    .stat-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }
    .stat-card {
      border-radius: 16px;
      border: 1px solid rgba(15, 23, 42, 0.08);
      background: rgba(255, 255, 255, 0.94);
      padding: 14px 16px;
      display: grid;
      gap: 6px;
    }
    .stat-card .label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.4px;
      color: var(--muted);
    }
    .stat-card .value {
      font-size: 20px;
      font-weight: 700;
      color: var(--text);
    }
    .stat-card .meta {
      font-size: 12px;
      color: var(--muted);
    }
    .message-stack {
      display: grid;
      gap: 10px;
    }
    .message {
      border-radius: 16px;
      padding: 14px 16px;
      font-size: 14px;
      background: rgba(37, 99, 235, 0.08);
      color: var(--primary);
      border: 1px solid rgba(37, 99, 235, 0.12);
    }
    .message.warning {
      background: rgba(249, 115, 22, 0.12);
      color: var(--warning);
      border-color: rgba(249, 115, 22, 0.18);
    }
    .message.danger {
      background: rgba(220, 38, 38, 0.12);
      color: var(--danger);
      border-color: rgba(220, 38, 38, 0.18);
    }
    .workspace {
      background: var(--surface);
      border-radius: 24px;
      border: 1px solid var(--border);
      box-shadow: 0 24px 48px rgba(15, 23, 42, 0.12);
      padding: clamp(22px, 3vw, 32px);
      display: grid;
      gap: 20px;
    }
    .tab-strip {
      display: inline-flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
      background: rgba(37, 99, 235, 0.06);
      padding: 6px;
      border-radius: 16px;
      width: fit-content;
    }
    .tab-strip button {
      border: none;
      border-radius: 12px;
      background: transparent;
      color: var(--muted);
      padding: 10px 16px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, transform 0.15s ease;
    }
    .tab-strip button.active {
      background: linear-gradient(135deg, #2563eb, #3b82f6);
      color: #fff;
      box-shadow: 0 12px 24px rgba(37, 99, 235, 0.26);
      transform: translateY(-1px);
    }
    .mode-container {
      display: none;
    }
    .mode-container.active {
      display: block;
    }
    .mode-layout {
      display: flex;
      flex-wrap: wrap;
      gap: 24px;
    }
    .mode-controls {
      flex: 0 0 280px;
      display: grid;
      gap: 18px;
      background: var(--surface-soft);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 18px;
    }
    .mode-results {
      flex: 1 1 420px;
      display: grid;
      gap: 18px;
    }
    .control-group {
      display: grid;
      gap: 10px;
    }
    .control-title {
      font-size: 13px;
      font-weight: 700;
      letter-spacing: 0.3px;
      color: var(--muted);
      text-transform: uppercase;
    }
    .control-item {
      display: grid;
      gap: 6px;
      font-size: 13px;
      font-weight: 600;
      color: var(--muted);
    }
    .control-item select,
    .control-item input[type="search"],
    .control-item input[type="text"] {
      border-radius: 12px;
      border: 1px solid var(--border-strong);
      padding: 10px 12px;
      font-size: 14px;
      background: #fff;
      color: var(--text);
    }
    .control-item select[multiple] {
      min-height: 180px;
    }
    .control-item select:focus,
    .control-item input:focus {
      outline: none;
      border-color: rgba(37, 99, 235, 0.6);
      box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.14);
    }
    .status-filter {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .status-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      padding: 6px 10px;
      background: rgba(37, 99, 235, 0.08);
      color: var(--muted);
      font-size: 13px;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .status-chip input {
      accent-color: #2563eb;
    }
    .status-chip.active {
      background: rgba(37, 99, 235, 0.18);
      color: var(--primary);
    }
    .status-actions {
      display: inline-flex;
      gap: 8px;
    }
    .tag {
      display: inline-flex;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      background: rgba(15, 23, 42, 0.08);
      color: var(--muted);
    }
    .tag.neutral {
      background: rgba(37, 99, 235, 0.12);
      color: var(--primary);
    }
    .tag.positive {
      background: rgba(34, 197, 94, 0.16);
      color: #15803d;
    }
    .tag.negative {
      background: rgba(220, 38, 38, 0.16);
      color: var(--danger);
    }
    .result-card {
      background: var(--surface);
      border-radius: 22px;
      border: 1px solid var(--border);
      box-shadow: 0 22px 44px rgba(15, 23, 42, 0.12);
      padding: clamp(24px, 3vw, 32px);
      display: grid;
      gap: 18px;
    }
    .summary-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }
    table {
      width: 100%;
      border-collapse: collapse;
      border-radius: 16px;
      overflow: hidden;
      font-size: 14px;
    }
    thead {
      background: var(--surface-soft);
    }
    th, td {
      padding: 12px 14px;
      border-bottom: 1px solid rgba(15, 23, 42, 0.08);
      text-align: left;
    }
    tbody tr:hover {
      background: rgba(37, 99, 235, 0.04);
    }
    .email-links {
      display: grid;
      gap: 8px;
    }
    .email-links a {
      font-size: 13px;
      color: var(--primary);
      text-decoration: none;
    }
    .email-links a:hover {
      text-decoration: underline;
    }
    .notice-block {
      border-radius: 16px;
      padding: 12px 16px;
      background: rgba(220, 38, 38, 0.08);
      color: var(--danger);
      border: 1px solid rgba(220, 38, 38, 0.18);
      font-size: 13px;
    }
    .notice-block.warning {
      background: rgba(249, 115, 22, 0.1);
      color: var(--warning);
      border-color: rgba(249, 115, 22, 0.18);
    }
    .notice-block.tip {
      background: rgba(37, 99, 235, 0.08);
      color: var(--primary);
      border-color: rgba(37, 99, 235, 0.14);
    }
    .status-present {
      color: var(--accent);
      font-weight: 600;
    }
    .status-late,
    .status-late-from-break {
      color: #f59e0b;
      font-weight: 600;
    }
    .status-left-early,
    .status-partial,
    .status-absent {
      color: var(--danger);
      font-weight: 600;
    }
    @media (max-width: 900px) {
      body { padding: 18px; }
      .mode-controls { flex: 1 1 100%; }
      .mode-results { flex: 1 1 100%; }
    }
    @media (max-width: 640px) {
      .tab-strip { width: 100%; justify-content: center; }
      .data-flex { flex-direction: column; }
    }
  </style>
</head>
<body>
  <div class="shell">
    <header class="header">
      <span class="brand">Analysis Suite</span>
      <h1>Attendance Insights</h1>
      <p class="subhead">Import daily CSV logs, reconcile them with rosters, and switch between targeted and cross-session views designed for lightweight, offline use.</p>
    </header>

    <section class="data-bar">
      <div class="data-flex">
        <div class="data-inputs">
          <label>Attendance CSVs (hold Cmd/Ctrl to select many)
            <input id="attendanceUpload" type="file" accept=".csv" multiple>
          </label>
          <div class="action-inline">
            <button type="button" class="ghost-btn" id="reloadServerBtn">Reload latest from server</button>
            <button type="button" class="ghost-btn" id="clearDataBtn">Clear loaded data</button>
          </div>
          <label>Roster CSV (one student ID per line)
            <input id="rosterUpload" type="file" accept=".csv,.txt">
          </label>
          <div class="action-inline">
            <button type="button" class="ghost-btn" id="clearRosterBtn">Clear roster</button>
            <span class="tag neutral" id="rosterSummary">No roster loaded</span>
          </div>
          <label>Email domain for follow-ups
            <input type="text" id="emailDomainInput" value="rave.ac.uk" placeholder="example.ac.uk">
          </label>
        </div>
        <div class="data-stats">
          <div class="stat-grid" id="datasetStats"></div>
        </div>
      </div>
      <div class="message-stack" id="dataMessages"></div>
    </section>

    <section class="workspace">
      <div class="tab-strip" role="tablist">
        <button type="button" class="active" data-mode="session" role="tab" aria-selected="true">Group · single session</button>
        <button type="button" data-mode="multi" role="tab" aria-selected="false">Groups · multiple sessions</button>
        <button type="button" data-mode="student" role="tab" aria-selected="false">Student · multiple sessions</button>
      </div>

      <div class="mode-container active" data-mode="session" role="tabpanel">
        <div class="mode-layout">
          <aside class="mode-controls">
            <div class="control-group">
              <div class="control-title">Session selection</div>
              <label class="control-item">Date
                <select id="sessionDateSelect"></select>
              </label>
              <label class="control-item">Session / group
                <select id="sessionKeySelect"></select>
              </label>
            </div>
            <div class="control-group">
              <div class="control-title">Statuses to include</div>
              <div class="status-filter" id="sessionStatusFilter"></div>
              <div class="status-actions">
                <button type="button" class="ghost-btn" data-mode="session" data-status-action="all">All</button>
                <button type="button" class="ghost-btn" data-mode="session" data-status-action="none">None</button>
              </div>
            </div>
            <div class="control-group">
              <div class="control-title">Exports</div>
              <button type="button" class="primary-btn" id="exportSessionBtn" disabled>Download session XLSX</button>
              <span class="tag neutral" id="sessionRosterTag">Roster not loaded</span>
            </div>
          </aside>
          <div class="mode-results" id="sessionResults"></div>
        </div>
      </div>

      <div class="mode-container" data-mode="multi" role="tabpanel" aria-hidden="true">
        <div class="mode-layout">
          <aside class="mode-controls">
            <div class="control-group">
              <div class="control-title">Sessions in scope</div>
              <label class="control-item">Select sessions
                <select id="multiSessionSelect" multiple></select>
              </label>
              <span class="tag neutral" id="multiSelectionTag">0 sessions selected</span>
            </div>
            <div class="control-group">
              <div class="control-title">Statuses to include</div>
              <div class="status-filter" id="multiStatusFilter"></div>
              <div class="status-actions">
                <button type="button" class="ghost-btn" data-mode="multi" data-status-action="all">All</button>
                <button type="button" class="ghost-btn" data-mode="multi" data-status-action="none">None</button>
              </div>
            </div>
            <div class="control-group">
              <div class="control-title">Exports</div>
              <button type="button" class="primary-btn" id="exportSummaryBtn" disabled>Download summary CSV</button>
            </div>
            <div class="notice-block tip">Tip: hold Cmd/Ctrl to select more than one session.</div>
          </aside>
          <div class="mode-results" id="multiResults"></div>
        </div>
      </div>

      <div class="mode-container" data-mode="student" role="tabpanel" aria-hidden="true">
        <div class="mode-layout">
          <aside class="mode-controls">
            <div class="control-group">
              <div class="control-title">Student</div>
              <label class="control-item">Student ID
                <input type="search" id="studentSearch" placeholder="e.g. 22012345" list="studentSuggestions" autocomplete="off">
              </label>
              <span class="tag neutral" id="studentSessionsTag">Student not selected</span>
            </div>
            <div class="control-group">
              <div class="control-title">Date window</div>
              <label class="control-item">Range
                <select id="studentDateRangeSelect">
                  <option value="30d">Last 30 days</option>
                  <option value="90d">Last 90 days</option>
                  <option value="last10">Last 10 sessions</option>
                  <option value="all">All sessions</option>
                </select>
              </label>
            </div>
            <div class="control-group">
              <div class="control-title">Exports</div>
              <button type="button" class="primary-btn" id="exportStudentBtn" disabled>Download student CSV</button>
            </div>
          </aside>
          <div class="mode-results" id="studentResults"></div>
        </div>
      </div>
    </section>
  </div>

  <datalist id="studentSuggestions"></datalist>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script type="module">
    const MODE = Object.freeze({
      SESSION: 'session',
      MULTI: 'multi',
      STUDENT: 'student'
    });

    const STATUS_ORDER = ['Present', 'Late', 'Late from break', 'Left Early', 'Partial', 'Absent'];
    const VALID_PHASES = new Set(['start', 'break1', 'break2', 'end']);
    const dateFormatter = new Intl.DateTimeFormat(undefined, { weekday: 'short', day: 'numeric', month: 'short', year: 'numeric' });
    const timeFormatter = new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit' });
    const percentFormatter = new Intl.NumberFormat(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 1 });

    const elements = {
      attendanceUpload: document.getElementById('attendanceUpload'),
      rosterUpload: document.getElementById('rosterUpload'),
      clearRosterBtn: document.getElementById('clearRosterBtn'),
      reloadServerBtn: document.getElementById('reloadServerBtn'),
      clearDataBtn: document.getElementById('clearDataBtn'),
      emailDomainInput: document.getElementById('emailDomainInput'),
      rosterSummary: document.getElementById('rosterSummary'),
      datasetStats: document.getElementById('datasetStats'),
      dataMessages: document.getElementById('dataMessages'),
      tabButtons: Array.from(document.querySelectorAll('.tab-strip button[data-mode]')),
      modeContainers: Array.from(document.querySelectorAll('.mode-container')),
      sessionDateSelect: document.getElementById('sessionDateSelect'),
      sessionKeySelect: document.getElementById('sessionKeySelect'),
      sessionStatusFilter: document.getElementById('sessionStatusFilter'),
      sessionRosterTag: document.getElementById('sessionRosterTag'),
      exportSessionBtn: document.getElementById('exportSessionBtn'),
      multiSessionSelect: document.getElementById('multiSessionSelect'),
      multiStatusFilter: document.getElementById('multiStatusFilter'),
      multiSelectionTag: document.getElementById('multiSelectionTag'),
      exportSummaryBtn: document.getElementById('exportSummaryBtn'),
      studentSearch: document.getElementById('studentSearch'),
      studentSuggestions: document.getElementById('studentSuggestions'),
      studentDateRangeSelect: document.getElementById('studentDateRangeSelect'),
      studentSessionsTag: document.getElementById('studentSessionsTag'),
      exportStudentBtn: document.getElementById('exportStudentBtn'),
      sessionResults: document.getElementById('sessionResults'),
      multiResults: document.getElementById('multiResults'),
      studentResults: document.getElementById('studentResults'),
      statusActionButtons: Array.from(document.querySelectorAll('.status-actions button[data-status-action]'))
    };

    const state = {
      selectedMode: MODE.SESSION,
      filters: {
        [MODE.SESSION]: new Set(STATUS_ORDER),
        [MODE.MULTI]: new Set(STATUS_ORDER)
      },
      rosterSet: new Set(),
      rosterVersion: 0,
      sessionsByKey: new Map(),
      sessionKeysSorted: [],
      dateToSessionKeys: new Map(),
      studentIndex: new Map(),
      allStudentIds: new Set(),
      datasetSources: new Set(),
      selectedDate: null,
      selectedSessionKey: null,
      selectedMultiSessionKeys: new Set(),
      selectedStudentId: '',
      studentDateRange: '30d',
      sessionExportRows: [],
      multiExportRows: [],
      studentExportRows: [],
      ingestionWarnings: [],
      parseErrors: [],
      emailDomain: elements.emailDomainInput.value.trim() || 'rave.ac.uk'
    };

    function normalizePhase(value) {
      const raw = (value || '').toString().trim().toLowerCase();
      if (raw === 'break' || raw === 'break 1' || raw === 'break1') return 'break1';
      if (raw === 'break 2' || raw === 'break2') return 'break2';
      if (raw === 'start' || raw === 'end') return raw;
      return raw;
    }

    function sanitizeId(id) {
      return (id || '').toString().replace(/[^0-9]/g, '').trim();
    }

    function extractDate(ts) {
      if (!ts) return '';
      const isoMatch = ts.match(/\\d{4}-\\d{2}-\\d{2}/);
      if (isoMatch) return isoMatch[0];
      const dateCandidate = new Date(ts);
      if (!Number.isNaN(dateCandidate.getTime())) {
        return [
          String(dateCandidate.getFullYear()).padStart(4, '0'),
          String(dateCandidate.getMonth() + 1).padStart(2, '0'),
          String(dateCandidate.getDate()).padStart(2, '0')
        ].join('-');
      }
      return '';
    }

    function toLocalDate(dateStr) {
      if (!dateStr) return '';
      const [y, m, d] = dateStr.split('-').map(Number);
      const date = new Date(y, (m || 1) - 1, d || 1);
      return dateFormatter.format(date);
    }

    function readableModuleGroup(session) {
      const module = session.module ? session.module.toUpperCase() : '';
      const group = session.group ? `Group ${session.group}` : '';
      if (module && group) return `${module} — ${group}`;
      if (module) return module;
      if (group) return group;
      return session.sid;
    }

    function statusClass(status) {
      return `status-${status.toLowerCase().replace(/\\s+/g, '-')}`;
    }

    function buildStatCard(label, value, meta) {
      const card = document.createElement('div');
      card.className = 'stat-card';
      const labelEl = document.createElement('div');
      labelEl.className = 'label';
      labelEl.textContent = label;
      const valueEl = document.createElement('div');
      valueEl.className = 'value';
      valueEl.textContent = value;
      card.appendChild(labelEl);
      card.appendChild(valueEl);
      if (meta) {
        const metaEl = document.createElement('div');
        metaEl.className = 'meta';
        metaEl.textContent = meta;
        card.appendChild(metaEl);
      }
      return card;
    }

    function getStatusFilter(mode) {
      return state.filters[mode] || new Set();
    }

    function setupStatusFilters() {
      [
        { mode: MODE.SESSION, container: elements.sessionStatusFilter },
        { mode: MODE.MULTI, container: elements.multiStatusFilter }
      ].forEach(({ mode, container }) => {
        container.innerHTML = '';
        STATUS_ORDER.forEach(status => {
          const id = `${mode}-status-${status.replace(/\\s+/g, '-')}`;
          const label = document.createElement('label');
          label.className = 'status-chip';
          label.htmlFor = id;
          const input = document.createElement('input');
          input.type = 'checkbox';
          input.id = id;
          input.value = status;
          input.dataset.mode = mode;
          input.checked = getStatusFilter(mode).has(status);
          input.addEventListener('change', handleStatusToggle);
          label.appendChild(input);
          const span = document.createElement('span');
          span.textContent = status;
          label.appendChild(span);
          if (input.checked) label.classList.add('active');
          container.appendChild(label);
        });
      });
    }

    function syncStatusFilterUI(mode) {
      const container = mode === MODE.SESSION ? elements.sessionStatusFilter : elements.multiStatusFilter;
      container.querySelectorAll('.status-chip').forEach(chip => {
        const input = chip.querySelector('input');
        if (!input) return;
        const checked = getStatusFilter(mode).has(input.value);
        input.checked = checked;
        chip.classList.toggle('active', checked);
      });
    }

    function handleStatusToggle(event) {
      const { value, checked, dataset } = event.target;
      const mode = dataset.mode;
      if (!value || !mode || !state.filters[mode]) return;
      if (checked) {
        state.filters[mode].add(value);
      } else {
        state.filters[mode].delete(value);
      }
      syncStatusFilterUI(mode);
      renderCurrentMode();
    }

    function handleStatusAction(event) {
      const { mode, statusAction } = event.currentTarget.dataset;
      if (!mode || !state.filters[mode]) return;
      if (statusAction === 'all') {
        STATUS_ORDER.forEach(status => state.filters[mode].add(status));
      } else if (statusAction === 'none') {
        state.filters[mode].clear();
      }
      syncStatusFilterUI(mode);
      renderCurrentMode();
    }

    function setMode(mode) {
      if (!Object.values(MODE).includes(mode)) return;
      state.selectedMode = mode;
      elements.tabButtons.forEach(btn => {
        const isActive = btn.dataset.mode === mode;
        btn.classList.toggle('active', isActive);
        btn.setAttribute('aria-selected', String(isActive));
      });
      elements.modeContainers.forEach(container => {
        const isActive = container.dataset.mode === mode;
        container.classList.toggle('active', isActive);
        container.setAttribute('aria-hidden', String(!isActive));
      });
      renderCurrentMode();
    }

    function parseCsvText(text, sourceLabel) {
      if (typeof Papa === 'undefined') {
        throw new Error('PapaParse library is not available.');
      }
      const result = Papa.parse(text, { header: true, skipEmptyLines: 'greedy' });
      const rows = Array.isArray(result.data) ? result.data : [];
      const errors = result.errors?.map(err => `${sourceLabel}: row ${err.row + 1} — ${err.message}`) || [];
      return { rows, errors };
    }

    function ingestAttendanceRows(rowSets) {
      state.sessionsByKey.clear();
      state.dateToSessionKeys.clear();
      state.studentIndex.clear();
      state.sessionKeysSorted = [];
      state.ingestionWarnings = [];
      state.parseErrors = [];
      state.datasetSources.clear();
      state.allStudentIds.clear();

      const moduleRe = /^[A-Z]{3}\\d{5}$/i;
      const groupRe = /group\\s*(\\w+)/i;

      rowSets.forEach(({ rows, sourceLabel }) => {
        state.datasetSources.add(sourceLabel);
        rows.forEach((row, index) => {
          const rawValues = Object.values(row || {});
          if (!rawValues.some(v => (v || '').toString().trim().length)) return;

          const sid = (row.sid || row.SID || row.session_id || '').toString().trim();
          if (!sid) {
            state.ingestionWarnings.push(`${sourceLabel}: row ${index + 2} skipped — missing session identifier.`);
            return;
          }

          const rawPhase = normalizePhase(row.phase || row.Phase || row.ph);
          if (!VALID_PHASES.has(rawPhase)) {
            state.ingestionWarnings.push(`${sourceLabel}: ${sid} row ${index + 2} skipped — unrecognised phase "${row.phase}".`);
            return;
          }

          const studentId = sanitizeId(row.student_id || row.Student_ID || row.studentId || row.StudentId);
          if (!studentId) {
            state.ingestionWarnings.push(`${sourceLabel}: ${sid} row ${index + 2} skipped — missing student ID.`);
            return;
          }

          const ts = row.ts_utc || row.timestamp || row.ts || '';
          const date = extractDate(ts);
          if (!date) {
            state.ingestionWarnings.push(`${sourceLabel}: ${sid} row ${index + 2} skipped — invalid timestamp.`);
            return;
          }

          let moduleCode = (row.module || row.Module || '').toString().trim();
          if (!moduleCode && moduleRe.test(sid)) {
            moduleCode = sid.slice(0, 8).toUpperCase();
          }

          let group = (row.group || row.Group || '').toString().trim();
          if (group) {
            const groupMatch = group.match(groupRe);
            if (groupMatch) {
              group = groupMatch[1];
            }
          } else if (row['group code']) {
            group = row['group code'].toString().trim();
          }

          const sessionKey = `${sid}__${date}`;
          let session = state.sessionsByKey.get(sessionKey);
          if (!session) {
            session = {
              key: sessionKey,
              sid,
              date,
              module: moduleCode,
              group,
              phaseUsage: new Set(),
              phasesByStudent: new Map(),
              duplicateCount: 0,
              sources: new Set(),
              cache: new Map()
            };
            state.sessionsByKey.set(sessionKey, session);
          }
          if (!session.module && moduleCode) session.module = moduleCode;
          if (!session.group && group) session.group = group;
          session.phaseUsage.add(rawPhase);
          session.sources.add(sourceLabel);

          let studentEntry = session.phasesByStudent.get(studentId);
          if (!studentEntry) {
            studentEntry = { phases: new Set(), timestamps: [], rawRows: [] };
            session.phasesByStudent.set(studentId, studentEntry);
          }
          if (studentEntry.phases.has(rawPhase)) {
            session.duplicateCount += 1;
          } else {
            studentEntry.phases.add(rawPhase);
          }
          if (ts) studentEntry.timestamps.push(ts);
          studentEntry.rawRows.push(row);

          state.allStudentIds.add(studentId);
          if (!state.studentIndex.has(studentId)) {
            state.studentIndex.set(studentId, new Set());
          }
          state.studentIndex.get(studentId).add(sessionKey);
        });
      });

      const sessions = Array.from(state.sessionsByKey.values());
      sessions.sort((a, b) => a.date.localeCompare(b.date) || a.sid.localeCompare(b.sid));
      state.sessionKeysSorted = sessions.map(session => session.key);

      sessions.forEach(session => {
        if (!state.dateToSessionKeys.has(session.date)) {
          state.dateToSessionKeys.set(session.date, []);
        }
        state.dateToSessionKeys.get(session.date).push(session.key);
      });
    }

    function populateSessionSelectors() {
      const dates = Array.from(state.dateToSessionKeys.keys()).sort();
      elements.sessionDateSelect.innerHTML = '';
      if (!dates.length) {
        elements.sessionDateSelect.innerHTML = '<option value="">No dates loaded</option>';
        elements.sessionKeySelect.innerHTML = '<option value="">No sessions available</option>';
        state.selectedDate = null;
        state.selectedSessionKey = null;
        return;
      }
      if (!state.selectedDate || !state.dateToSessionKeys.has(state.selectedDate)) {
        state.selectedDate = dates[dates.length - 1];
      }
      dates.forEach(date => {
        const option = document.createElement('option');
        option.value = date;
        option.textContent = toLocalDate(date);
        if (date === state.selectedDate) option.selected = true;
        elements.sessionDateSelect.appendChild(option);
      });
      populateSessionKeySelect(state.selectedDate);
    }

    function populateSessionKeySelect(date) {
      elements.sessionKeySelect.innerHTML = '';
      const sessionKeys = state.dateToSessionKeys.get(date) || [];
      if (!sessionKeys.length) {
        elements.sessionKeySelect.innerHTML = '<option value="">No sessions on this date</option>';
        state.selectedSessionKey = null;
        return;
      }
      if (!state.selectedSessionKey || !sessionKeys.includes(state.selectedSessionKey)) {
        state.selectedSessionKey = sessionKeys[0];
      }
      sessionKeys.forEach(key => {
        const session = state.sessionsByKey.get(key);
        const option = document.createElement('option');
        option.value = key;
        option.textContent = readableModuleGroup(session);
        if (key === state.selectedSessionKey) option.selected = true;
        elements.sessionKeySelect.appendChild(option);
      });
    }

    function populateMultiSessionSelect() {
      elements.multiSessionSelect.innerHTML = '';
      if (!state.sessionKeysSorted.length) {
        elements.multiSessionSelect.innerHTML = '<option value="">No sessions loaded</option>';
        state.selectedMultiSessionKeys.clear();
        elements.multiSelectionTag.textContent = '0 sessions selected';
        return;
      }
      if (!state.selectedMultiSessionKeys.size) {
        state.selectedMultiSessionKeys = new Set(state.sessionKeysSorted.slice(-3));
      }
      state.sessionKeysSorted.forEach(key => {
        const session = state.sessionsByKey.get(key);
        const option = document.createElement('option');
        option.value = key;
        option.textContent = `${toLocalDate(session.date)} · ${readableModuleGroup(session)}`;
        option.selected = state.selectedMultiSessionKeys.has(key);
        elements.multiSessionSelect.appendChild(option);
      });
      elements.multiSelectionTag.textContent = `${state.selectedMultiSessionKeys.size} session${state.selectedMultiSessionKeys.size === 1 ? '' : 's'} selected`;
    }

    function populateStudentSuggestions() {
      const studentIds = Array.from(state.studentIndex.keys()).sort();
      elements.studentSuggestions.innerHTML = '';
      studentIds.forEach(id => {
        const option = document.createElement('option');
        option.value = id;
        elements.studentSuggestions.appendChild(option);
      });
      if (state.selectedStudentId && !state.studentIndex.has(state.selectedStudentId)) {
        state.selectedStudentId = '';
      }
      elements.studentSearch.value = state.selectedStudentId;
    }

    function updateRosterSummary() {
      if (state.rosterSet.size) {
        elements.rosterSummary.textContent = `${state.rosterSet.size} rostered IDs`;
        elements.rosterSummary.className = 'tag neutral';
        elements.sessionRosterTag.textContent = `${state.rosterSet.size} in roster`;
      } else {
        elements.rosterSummary.textContent = 'No roster loaded';
        elements.rosterSummary.className = 'tag neutral';
        elements.sessionRosterTag.textContent = 'Roster not loaded';
      }
    }

    function clearSessionCaches() {
      state.sessionsByKey.forEach(session => {
        if (session.cache) session.cache.clear();
      });
    }

    function buildSessionAnalytics(session) {
      const rosterVersionKey = `roster-${state.rosterVersion}`;
      if (session.cache && session.cache.has(rosterVersionKey)) {
        return session.cache.get(rosterVersionKey);
      }
      const break1Used = session.phaseUsage.has('break1');
      const break2Used = session.phaseUsage.has('break2');
      const rosterHasEntries = state.rosterSet.size > 0;

      const combinedStudentIds = new Set();
      if (rosterHasEntries) {
        state.rosterSet.forEach(id => combinedStudentIds.add(id));
      }
      session.phasesByStudent.forEach((_, id) => combinedStudentIds.add(id));

      const counts = STATUS_ORDER.reduce((acc, status) => {
        acc[status] = 0;
        return acc;
      }, {});
      const rows = [];
      const missingFromRoster = [];
      const outOfRoster = [];

      combinedStudentIds.forEach(studentId => {
        const studentEntry = session.phasesByStudent.get(studentId);
        const phases = studentEntry ? studentEntry.phases : new Set();
        const status = determineStatus(phases, break1Used, break2Used);
        counts[status] += 1;
        const startPhase = phases.has('start') ? 'Present' : 'Absent';
        const break1Phase = break1Used ? (phases.has('break1') ? 'Present' : 'Absent') : '—';
        const break2Phase = break2Used ? (phases.has('break2') ? 'Present' : 'Absent') : '—';
        const endPhase = phases.has('end') ? 'Present' : 'Absent';
        const lastSeen = studentEntry && studentEntry.timestamps.length
          ? timeFormatter.format(new Date(studentEntry.timestamps.sort().slice(-1)[0]))
          : '—';

        rows.push({
          studentId,
          status,
          phases,
          startPhase,
          break1Phase,
          break2Phase,
          endPhase,
          lastSeen
        });

        if (rosterHasEntries) {
          if (!state.rosterSet.has(studentId)) {
            outOfRoster.push(studentId);
          } else if (!studentEntry || !studentEntry.phases.size) {
            missingFromRoster.push(studentId);
          }
        }
      });

      rows.sort((a, b) => {
        const statusDiff = STATUS_ORDER.indexOf(a.status) - STATUS_ORDER.indexOf(b.status);
        if (statusDiff !== 0) return statusDiff;
        return a.studentId.localeCompare(b.studentId);
      });

      const totalStudents = rows.length;
      const presentCount = counts['Present'] || 0;
      const analytics = {
        rows,
        counts,
        totals: {
          totalStudents,
          presentCount,
          presentPercentage: totalStudents ? (presentCount / totalStudents) * 100 : 0
        },
        break1Used,
        break2Used,
        missingFromRoster,
        outOfRoster,
        duplicateCount: session.duplicateCount
      };

      session.cache.set(rosterVersionKey, analytics);
      return analytics;
    }

    function determineStatus(phases, expectsBreak1, expectsBreak2) {
      const hasStart = phases.has('start');
      const hasBreak1 = phases.has('break1');
      const hasBreak2 = phases.has('break2');
      const hasEnd = phases.has('end');

      if (!hasStart && (hasBreak1 || hasBreak2 || hasEnd)) return 'Late';
      if (hasStart && hasEnd) {
        const missingBreak1 = expectsBreak1 && !hasBreak1;
        const missingBreak2 = expectsBreak2 && !hasBreak2;
        if (!missingBreak1 && !missingBreak2) return 'Present';
        return 'Late from break';
      }
      if (hasStart && !hasEnd) return 'Left Early';
      if (hasStart || hasBreak1 || hasBreak2 || hasEnd) return 'Partial';
      return 'Absent';
    }

    function renderDataMessages() {
      elements.dataMessages.innerHTML = '';
      if (state.parseErrors.length) {
        const danger = document.createElement('div');
        danger.className = 'message danger';
        danger.innerHTML = state.parseErrors.slice(0, 6).map(msg => `<div>${msg}</div>`).join('');
        if (state.parseErrors.length > 6) {
          danger.innerHTML += `<div>…and ${state.parseErrors.length - 6} more issues.</div>`;
        }
        elements.dataMessages.appendChild(danger);
      } else if (state.ingestionWarnings.length) {
        const warning = document.createElement('div');
        warning.className = 'message warning';
        warning.innerHTML = state.ingestionWarnings.slice(0, 6).map(msg => `<div>${msg}</div>`).join('');
        if (state.ingestionWarnings.length > 6) {
          warning.innerHTML += `<div>…and ${state.ingestionWarnings.length - 6} more warnings.</div>`;
        }
        elements.dataMessages.appendChild(warning);
      }
    }

    function updateDatasetStats() {
      elements.datasetStats.innerHTML = '';
      const totalSessions = state.sessionsByKey.size;
      const totalDates = state.dateToSessionKeys.size;
      const totalStudents = state.allStudentIds.size;
      const rosterCount = state.rosterSet.size;

      const dateValues = Array.from(state.dateToSessionKeys.keys()).sort();
      const dateRange = dateValues.length
        ? `${toLocalDate(dateValues[0])} → ${toLocalDate(dateValues[dateValues.length - 1])}`
        : '—';

      const sourceCount = state.datasetSources.size;

      elements.datasetStats.appendChild(buildStatCard('Sessions', `${totalSessions}`, `${totalDates} teaching days`));
      elements.datasetStats.appendChild(buildStatCard('Unique students', `${totalStudents}`, rosterCount ? `${rosterCount} rostered` : 'No roster loaded'));
      elements.datasetStats.appendChild(buildStatCard('Date span', dateRange, sourceCount ? `${sourceCount} source file${sourceCount === 1 ? '' : 's'}` : 'No files loaded'));
    }

    function createMessageCard(text, variant = 'info') {
      const div = document.createElement('div');
      div.className = 'result-card';
      const message = document.createElement('div');
      message.className = `message${variant === 'warning' ? ' warning' : variant === 'danger' ? ' danger' : ''}`;
      message.textContent = text;
      div.appendChild(message);
      return div;
    }

    function renderSessionMode() {
      elements.sessionResults.innerHTML = '';
      if (!state.sessionsByKey.size) {
        elements.sessionResults.appendChild(createMessageCard('Load attendance CSVs to get started.'));
        elements.exportSessionBtn.disabled = true;
        return;
      }
      if (!state.selectedSessionKey || !state.sessionsByKey.has(state.selectedSessionKey)) {
        elements.sessionResults.appendChild(createMessageCard('Choose a date and session to display attendance.'));
        elements.exportSessionBtn.disabled = true;
        return;
      }

      const session = state.sessionsByKey.get(state.selectedSessionKey);
      const analytics = buildSessionAnalytics(session);
      state.sessionExportRows = analytics.rows;

      const filterSet = getStatusFilter(MODE.SESSION);
      const visibleRows = analytics.rows.filter(row => filterSet.has(row.status));
      const focusCount = visibleRows.length;

      const card = document.createElement('div');
      card.className = 'result-card';

      const title = document.createElement('h2');
      title.textContent = `${session.sid} · ${toLocalDate(session.date)}`;
      card.appendChild(title);

      const subtitle = document.createElement('div');
      subtitle.className = 'tag';
      subtitle.textContent = `${readableModuleGroup(session)} · ${analytics.rows.length} students`;
      card.appendChild(subtitle);

      const summary = document.createElement('div');
      summary.className = 'summary-grid';
      summary.appendChild(buildStatCard('Present', `${analytics.counts['Present']}`, `${percentFormatter.format(analytics.totals.presentPercentage)}%`));
      summary.appendChild(buildStatCard('In focus', `${focusCount}`, `${filterSet.size} statuses`));
      summary.appendChild(buildStatCard('Late / break issues', `${analytics.counts['Late']} + ${analytics.counts['Late from break']}`, 'Late · late from break'));
      summary.appendChild(buildStatCard('At risk', `${analytics.counts['Absent'] + analytics.counts['Partial'] + analytics.counts['Left Early']}`, 'Absent · partial · left early'));
      card.appendChild(summary);

      if (analytics.missingFromRoster.length) {
        const missingBlock = document.createElement('div');
        missingBlock.className = 'notice-block';
        missingBlock.innerHTML = `<strong>${analytics.missingFromRoster.length} rostered students missing:</strong> ${analytics.missingFromRoster.join(', ')}`;
        card.appendChild(missingBlock);
        elements.sessionRosterTag.className = 'tag negative';
        elements.sessionRosterTag.textContent = `${analytics.missingFromRoster.length} missing from roster`;
      } else {
        elements.sessionRosterTag.className = 'tag neutral';
        elements.sessionRosterTag.textContent = state.rosterSet.size ? `${state.rosterSet.size} in roster` : 'Roster not loaded';
      }
      if (analytics.outOfRoster.length) {
        const extraBlock = document.createElement('div');
        extraBlock.className = 'notice-block warning';
        extraBlock.innerHTML = `<strong>${analytics.outOfRoster.length} not in roster:</strong> ${analytics.outOfRoster.join(', ')}`;
        card.appendChild(extraBlock);
      }
      if (analytics.duplicateCount) {
        const duplicateBlock = document.createElement('div');
        duplicateBlock.className = 'notice-block warning';
        duplicateBlock.textContent = `${analytics.duplicateCount} duplicate check-ins (same student/phase) detected.`;
        card.appendChild(duplicateBlock);
      }

      const table = document.createElement('table');
      table.innerHTML = '<thead><tr><th>Student ID</th><th>Start</th><th>Break 1</th><th>Break 2</th><th>End</th><th>Status</th><th>Last activity</th></tr></thead>';
      const tbody = document.createElement('tbody');
      if (!visibleRows.length) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 7;
        td.textContent = 'No students match the selected statuses.';
        tr.appendChild(td);
        tbody.appendChild(tr);
      } else {
        visibleRows.forEach(row => {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${row.studentId}</td>
            <td>${row.startPhase === 'Present' ? '✔' : '—'}</td>
            <td>${row.break1Phase === 'Present' ? '✔' : (row.break1Phase === '—' ? '—' : '✖')}</td>
            <td>${row.break2Phase === 'Present' ? '✔' : (row.break2Phase === '—' ? '—' : '✖')}</td>
            <td>${row.endPhase === 'Present' ? '✔' : '—'}</td>
            <td class="${statusClass(row.status)}">${row.status}</td>
            <td>${row.lastSeen}</td>
          `;
          tbody.appendChild(tr);
        });
      }
      table.appendChild(tbody);
      card.appendChild(table);

      const flaggedRows = analytics.rows.filter(row => row.status !== 'Present');
      if (flaggedRows.length) {
        const followUpTitle = document.createElement('div');
        followUpTitle.textContent = 'Follow-up email drafts';
        followUpTitle.style.fontWeight = '600';
        card.appendChild(followUpTitle);
        const links = document.createElement('div');
        links.className = 'email-links';
        flaggedRows.forEach(row => {
          const eml = generateEmailDraft(session, row);
          const blob = new Blob([eml], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `${row.studentId}_${session.sid}_${row.status.replace(/\\s+/g, '-')}.eml`;
          link.textContent = `Draft for ${row.studentId} (${row.status})`;
          link.addEventListener('click', () => {
            setTimeout(() => URL.revokeObjectURL(url), 2000);
          });
          links.appendChild(link);
        });
        card.appendChild(links);
      }

      elements.sessionResults.appendChild(card);
      elements.exportSessionBtn.disabled = !analytics.rows.length;
    }

    function renderMultiMode() {
      elements.multiResults.innerHTML = '';
      if (!state.sessionsByKey.size) {
        elements.multiResults.appendChild(createMessageCard('Load attendance CSVs to compare multiple sessions.'));
        elements.exportSummaryBtn.disabled = true;
        elements.multiSelectionTag.textContent = '0 sessions selected';
        return;
      }
      const selectedKeys = Array.from(state.selectedMultiSessionKeys).filter(key => state.sessionsByKey.has(key));
      if (!selectedKeys.length) {
        elements.multiResults.appendChild(createMessageCard('Select one or more sessions to compare.'));
        elements.exportSummaryBtn.disabled = true;
        elements.multiSelectionTag.textContent = '0 sessions selected';
        return;
      }
      elements.multiSelectionTag.textContent = `${selectedKeys.length} session${selectedKeys.length === 1 ? '' : 's'} selected`;

      const filterSet = getStatusFilter(MODE.MULTI);
      const rows = selectedKeys.map(key => {
        const session = state.sessionsByKey.get(key);
        const analytics = buildSessionAnalytics(session);
        const focusCount = analytics.rows.filter(row => filterSet.has(row.status)).length;
        return { session, analytics, focusCount };
      }).sort((a, b) => a.session.date.localeCompare(b.session.date));

      const card = document.createElement('div');
      card.className = 'result-card';

      const title = document.createElement('h2');
      title.textContent = `Summary across ${rows.length} session${rows.length === 1 ? '' : 's'}`;
      card.appendChild(title);

      const focusTag = document.createElement('div');
      focusTag.className = 'tag neutral';
      focusTag.textContent = `Statuses in focus: ${Array.from(filterSet).join(', ') || 'None'}`;
      card.appendChild(focusTag);

      const table = document.createElement('table');
      table.innerHTML = `
        <thead>
          <tr>
            <th>Session</th>
            <th>Date</th>
            <th>Total</th>
            <th>Present</th>
            <th>Late</th>
            <th>Late (break)</th>
            <th>Left early</th>
            <th>Partial</th>
            <th>Absent</th>
            <th>Focus total</th>
            <th>Roster gaps</th>
            <th>Out-of-roster</th>
            <th>Duplicates</th>
          </tr>
        </thead>`;
      const tbody = document.createElement('tbody');

      const totals = {
        students: 0,
        present: 0,
        late: 0,
        lateBreak: 0,
        leftEarly: 0,
        partial: 0,
        absent: 0,
        focus: 0,
        rosterMissing: 0,
        outOfRoster: 0,
        duplicates: 0
      };

      state.multiExportRows = [];

      rows.forEach(({ session, analytics, focusCount }) => {
        totals.students += analytics.totals.totalStudents;
        totals.present += analytics.counts['Present'];
        totals.late += analytics.counts['Late'];
        totals.lateBreak += analytics.counts['Late from break'];
        totals.leftEarly += analytics.counts['Left Early'];
        totals.partial += analytics.counts['Partial'];
        totals.absent += analytics.counts['Absent'];
        totals.focus += focusCount;
        totals.rosterMissing += analytics.missingFromRoster.length;
        totals.outOfRoster += analytics.outOfRoster.length;
        totals.duplicates += analytics.duplicateCount;

        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${readableModuleGroup(session)}</td>
          <td>${toLocalDate(session.date)}</td>
          <td>${analytics.totals.totalStudents}</td>
          <td>${analytics.counts['Present']}</td>
          <td>${analytics.counts['Late']}</td>
          <td>${analytics.counts['Late from break']}</td>
          <td>${analytics.counts['Left Early']}</td>
          <td>${analytics.counts['Partial']}</td>
          <td>${analytics.counts['Absent']}</td>
          <td>${focusCount}</td>
          <td>${analytics.missingFromRoster.length}</td>
          <td>${analytics.outOfRoster.length}</td>
          <td>${analytics.duplicateCount}</td>
        `;
        tbody.appendChild(tr);

        state.multiExportRows.push({
          Session: readableModuleGroup(session),
          Date: session.date,
          Total: analytics.totals.totalStudents,
          Present: analytics.counts['Present'],
          Late: analytics.counts['Late'],
          LateFromBreak: analytics.counts['Late from break'],
          LeftEarly: analytics.counts['Left Early'],
          Partial: analytics.counts['Partial'],
          Absent: analytics.counts['Absent'],
          FocusTotal: focusCount,
          RosterMissing: analytics.missingFromRoster.length,
          OutOfRoster: analytics.outOfRoster.length,
          Duplicates: analytics.duplicateCount
        });
      });

      const totalRow = document.createElement('tr');
      totalRow.innerHTML = `
        <td><strong>Total</strong></td>
        <td>—</td>
        <td><strong>${totals.students}</strong></td>
        <td><strong>${totals.present}</strong></td>
        <td><strong>${totals.late}</strong></td>
        <td><strong>${totals.lateBreak}</strong></td>
        <td><strong>${totals.leftEarly}</strong></td>
        <td><strong>${totals.partial}</strong></td>
        <td><strong>${totals.absent}</strong></td>
        <td><strong>${totals.focus}</strong></td>
        <td><strong>${totals.rosterMissing}</strong></td>
        <td><strong>${totals.outOfRoster}</strong></td>
        <td><strong>${totals.duplicates}</strong></td>
      `;
      tbody.appendChild(totalRow);

      table.appendChild(tbody);
      card.appendChild(table);
      elements.multiResults.appendChild(card);
      elements.exportSummaryBtn.disabled = !state.multiExportRows.length;
    }

    function renderStudentMode() {
      elements.studentResults.innerHTML = '';
      if (!state.sessionsByKey.size) {
        elements.studentResults.appendChild(createMessageCard('Load attendance CSVs to explore student history.'));
        elements.exportStudentBtn.disabled = true;
        elements.studentSessionsTag.textContent = 'Student not selected';
        return;
      }
      const studentId = sanitizeId(state.selectedStudentId);
      if (!studentId) {
        elements.studentResults.appendChild(createMessageCard('Enter or select a student ID to review their sessions.'));
        elements.exportStudentBtn.disabled = true;
        elements.studentSessionsTag.textContent = 'Student not selected';
        return;
      }
      const sessionKeys = state.studentIndex.get(studentId);
      if (!sessionKeys || !sessionKeys.size) {
        elements.studentResults.appendChild(createMessageCard(`No attendance records found for ${studentId}.`, 'warning'));
        elements.exportStudentBtn.disabled = true;
        elements.studentSessionsTag.textContent = 'No sessions for this student';
        return;
      }

      const allRows = Array.from(sessionKeys).map(key => {
        const session = state.sessionsByKey.get(key);
        if (!session) return null;
        const analytics = buildSessionAnalytics(session);
        const row = analytics.rows.find(entry => entry.studentId === studentId);
        if (!row) return null;
        return { session, analytics, row };
      }).filter(Boolean).sort((a, b) => a.session.date.localeCompare(b.session.date));

      const filteredRows = applyStudentDateFilter(allRows, state.studentDateRange);
      state.studentExportRows = filteredRows.map(item => ({
        StudentID: studentId,
        Date: item.session.date,
        Session: item.session.sid,
        Module: readableModuleGroup(item.session),
        Start: item.row.startPhase,
        Break1: item.row.break1Phase,
        Break2: item.row.break2Phase,
        End: item.row.endPhase,
        Status: item.row.status,
        LastActivity: item.row.lastSeen
      }));

      elements.studentSessionsTag.textContent = `${filteredRows.length} session${filteredRows.length === 1 ? '' : 's'} in view`;

      const card = document.createElement('div');
      card.className = 'result-card';

      const title = document.createElement('h2');
      title.textContent = `Student ${studentId}`;
      card.appendChild(title);

      const summary = document.createElement('div');
      summary.className = 'summary-grid';
      const statusTotals = STATUS_ORDER.reduce((acc, status) => {
        acc[status] = 0;
        return acc;
      }, {});
      filteredRows.forEach(item => {
        statusTotals[item.row.status] += 1;
      });
      const presentCount = statusTotals['Present'] || 0;
      const totalSessions = filteredRows.length;
      const attendanceRate = totalSessions ? (presentCount / totalSessions) * 100 : 0;
      const riskCount = statusTotals['Absent'] + statusTotals['Partial'] + statusTotals['Left Early'];
      summary.appendChild(buildStatCard('Sessions', `${totalSessions}`, `${state.studentDateRange === 'all' ? 'All time' : state.studentDateRange}`));
      summary.appendChild(buildStatCard('Present', `${presentCount}`, `${percentFormatter.format(attendanceRate)}% rate`));
      summary.appendChild(buildStatCard('Late / break issues', `${statusTotals['Late']} + ${statusTotals['Late from break']}`, 'Late · late from break'));
      summary.appendChild(buildStatCard('At risk flags', `${riskCount}`, 'Absent · partial · left early'));
      card.appendChild(summary);

      const table = document.createElement('table');
      table.innerHTML = '<thead><tr><th>Date</th><th>Session</th><th>Start</th><th>Break 1</th><th>Break 2</th><th>End</th><th>Status</th><th>Last activity</th></tr></thead>';
      const tbody = document.createElement('tbody');
      if (!filteredRows.length) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 8;
        td.textContent = 'No sessions fall inside the selected date window.';
        tr.appendChild(td);
        tbody.appendChild(tr);
      } else {
        filteredRows.forEach(item => {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${toLocalDate(item.session.date)}</td>
            <td>${readableModuleGroup(item.session)}</td>
            <td>${item.row.startPhase}</td>
            <td>${item.row.break1Phase}</td>
            <td>${item.row.break2Phase}</td>
            <td>${item.row.endPhase}</td>
            <td class="${statusClass(item.row.status)}">${item.row.status}</td>
            <td>${item.row.lastSeen}</td>
          `;
          tbody.appendChild(tr);
        });
      }
      table.appendChild(tbody);
      card.appendChild(table);

      if (totalSessions && !presentCount) {
        const alert = document.createElement('div');
        alert.className = 'notice-block';
        alert.textContent = 'This student has zero fully present sessions in the selected window.';
        card.appendChild(alert);
      }

      elements.studentResults.appendChild(card);
      elements.exportStudentBtn.disabled = !filteredRows.length;
    }

    function applyStudentDateFilter(rows, range) {
      if (range === 'all') return rows;
      const now = new Date();
      if (range === '30d' || range === '90d') {
        const windowDays = range === '30d' ? 30 : 90;
        const threshold = new Date(now);
        threshold.setDate(now.getDate() - windowDays);
        return rows.filter(item => {
          const [y, m, d] = item.session.date.split('-').map(Number);
          const date = new Date(y, (m || 1) - 1, d || 1);
          return date >= threshold;
        });
      }
      if (range === 'last10') {
        return rows.slice(-10);
      }
      return rows;
    }

    function generateEmailDraft(session, row) {
      const lb = '\\r\\n';
      const to = `${row.studentId}@${state.emailDomain}`;
      const subject = `[Attendance Alert] ${session.sid} ${session.date}`;
      const body = [
        'Dear Student,',
        '',
        `Our records for session ${session.sid} on ${toLocalDate(session.date)} indicate:`,
        `- Start: ${row.startPhase}`,
        session.phaseUsage?.has?.('break1') ? `- Break 1: ${row.break1Phase}` : null,
        session.phaseUsage?.has?.('break2') ? `- Break 2: ${row.break2Phase}` : null,
        `- End: ${row.endPhase}`,
        '',
        'Attendance is monitored and may affect academic progress and visa compliance.',
        '',
        'Regards,',
        'Ravensbourne University London'
      ].filter(Boolean).join(lb);

      return [
        `To: ${to}`,
        `Subject: ${subject}`,
        'Content-Type: text/plain; charset=utf-8',
        '',
        body
      ].join(lb);
    }

    function exportSessionToExcel() {
      if (!state.sessionExportRows.length || typeof XLSX === 'undefined') return;
      const worksheet = XLSX.utils.json_to_sheet(state.sessionExportRows.map(row => ({
        'Student ID': row.studentId,
        'Status': row.status,
        'Start': row.startPhase,
        'Break 1': row.break1Phase,
        'Break 2': row.break2Phase,
        'End': row.endPhase,
        'Last activity': row.lastSeen
      })));
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, 'Session');
      const session = state.sessionsByKey.get(state.selectedSessionKey);
      const filename = `${session ? session.sid : 'session'}_${session ? session.date : Date.now()}.xlsx`;
      XLSX.writeFile(workbook, filename);
    }

    function exportSummaryCsv() {
      if (!state.multiExportRows.length) return;
      const header = Object.keys(state.multiExportRows[0]);
      const lines = [header.join(',')];
      state.multiExportRows.forEach(row => {
        const line = header.map(key => row[key]).join(',');
        lines.push(line);
      });
      triggerDownload(lines.join('\\n'), 'session_summary.csv');
    }

    function exportStudentCsv() {
      if (!state.studentExportRows.length) return;
      const header = Object.keys(state.studentExportRows[0]);
      const lines = [header.join(',')];
      state.studentExportRows.forEach(row => {
        const line = header.map(key => row[key]).join(',');
        lines.push(line);
      });
      triggerDownload(lines.join('\\n'), `student_${state.selectedStudentId || 'report'}.csv`);
    }

    function triggerDownload(content, filename) {
      const blob = new Blob([content], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      setTimeout(() => URL.revokeObjectURL(url), 2000);
    }

    async function loadAttendanceFromServer() {
      try {
        const response = await fetch('/api/csv/current');
        if (!response.ok) throw new Error('Attendance CSV not found on server.');
        const text = await response.text();
        applyAttendanceData([text], 'Server CSV');
      } catch (err) {
        state.parseErrors = [err.message];
        renderAll();
      }
    }

    function applyAttendanceData(texts, sourceLabel = 'Uploaded CSV') {
      const parsedSets = [];
      const parseErrors = [];
      texts.forEach((text, idx) => {
        const label = texts.length > 1 ? `${sourceLabel} ${idx + 1}` : sourceLabel;
        try {
          const { rows, errors } = parseCsvText(text, label);
          parsedSets.push({ rows, sourceLabel: label });
          if (errors.length) parseErrors.push(...errors);
        } catch (err) {
          parseErrors.push(`${label}: ${err.message}`);
        }
      });

      state.parseErrors = parseErrors;
      ingestAttendanceRows(parsedSets);
      populateSessionSelectors();
      populateMultiSessionSelect();
      populateStudentSuggestions();
      updateRosterSummary();
      renderAll();
    }

    function clearDataset() {
      state.sessionsByKey.clear();
      state.dateToSessionKeys.clear();
      state.sessionKeysSorted = [];
      state.studentIndex.clear();
      state.allStudentIds.clear();
      state.datasetSources.clear();
      state.selectedDate = null;
      state.selectedSessionKey = null;
      state.selectedMultiSessionKeys.clear();
      state.selectedStudentId = '';
      state.sessionExportRows = [];
      state.multiExportRows = [];
      state.studentExportRows = [];
      state.ingestionWarnings = [];
      state.parseErrors = [];
      populateSessionSelectors();
      populateMultiSessionSelect();
      populateStudentSuggestions();
      renderAll();
    }

    function renderCurrentMode() {
      switch (state.selectedMode) {
        case MODE.SESSION:
          renderSessionMode();
          break;
        case MODE.MULTI:
          renderMultiMode();
          break;
        case MODE.STUDENT:
          renderStudentMode();
          break;
        default:
          break;
      }
    }

    function renderAll() {
      renderDataMessages();
      updateDatasetStats();
      renderCurrentMode();
    }

    function handleAttendanceUpload(event) {
      const files = Array.from(event.target.files || []);
      if (!files.length) return;
      Promise.all(files.map(file => file.text()))
        .then(texts => applyAttendanceData(texts, 'Upload'))
        .catch(err => {
          state.parseErrors = [err.message];
          renderAll();
        });
    }

    function handleRosterUpload(event) {
      const file = event.target.files?.[0];
      if (!file) return;
      file.text().then(text => {
        const lines = text.split(/\\r?\\n/).map(line => sanitizeId(line));
        const ids = lines.filter(Boolean);
        state.rosterSet = new Set(ids);
        state.rosterVersion += 1;
        clearSessionCaches();
        updateRosterSummary();
        renderCurrentMode();
        updateDatasetStats();
      }).catch(err => {
        state.parseErrors = [`Roster: ${err.message}`];
        renderAll();
      });
    }

    function clearRoster() {
      state.rosterSet.clear();
      state.rosterVersion += 1;
      clearSessionCaches();
      updateRosterSummary();
      renderCurrentMode();
      updateDatasetStats();
    }

    function handleSessionDateChange(event) {
      state.selectedDate = event.target.value;
      populateSessionKeySelect(state.selectedDate);
      renderSessionMode();
    }

    function handleSessionKeyChange(event) {
      state.selectedSessionKey = event.target.value;
      renderSessionMode();
    }

    function handleMultiSessionChange(event) {
      const options = Array.from(event.target.options || []);
      state.selectedMultiSessionKeys = new Set(options.filter(opt => opt.selected).map(opt => opt.value));
      elements.multiSelectionTag.textContent = `${state.selectedMultiSessionKeys.size} session${state.selectedMultiSessionKeys.size === 1 ? '' : 's'} selected`;
      renderMultiMode();
    }

    function handleStudentSearch(event) {
      state.selectedStudentId = sanitizeId(event.target.value);
      renderStudentMode();
    }

    function handleStudentDateRangeChange(event) {
      state.studentDateRange = event.target.value;
      renderStudentMode();
    }

    function handleEmailDomainChange(event) {
      const value = event.target.value.trim();
      if (value) {
        state.emailDomain = value.replace(/^@/, '');
      }
    }

    elements.tabButtons.forEach(button => button.addEventListener('click', () => setMode(button.dataset.mode)));
    elements.attendanceUpload.addEventListener('change', handleAttendanceUpload);
    elements.reloadServerBtn.addEventListener('click', loadAttendanceFromServer);
    elements.clearDataBtn.addEventListener('click', clearDataset);
    elements.rosterUpload.addEventListener('change', handleRosterUpload);
    elements.clearRosterBtn.addEventListener('click', clearRoster);
    elements.sessionDateSelect.addEventListener('change', handleSessionDateChange);
    elements.sessionKeySelect.addEventListener('change', handleSessionKeyChange);
    elements.multiSessionSelect.addEventListener('change', handleMultiSessionChange);
    elements.studentSearch.addEventListener('change', handleStudentSearch);
    elements.studentSearch.addEventListener('blur', handleStudentSearch);
    elements.studentDateRangeSelect.addEventListener('change', handleStudentDateRangeChange);
    elements.emailDomainInput.addEventListener('input', handleEmailDomainChange);
    elements.exportSessionBtn.addEventListener('click', exportSessionToExcel);
    elements.exportSummaryBtn.addEventListener('click', exportSummaryCsv);
    elements.exportStudentBtn.addEventListener('click', exportStudentCsv);
    elements.statusActionButtons.forEach(button => button.addEventListener('click', handleStatusAction));

    setupStatusFilters();
    updateRosterSummary();
    updateDatasetStats();
    renderAll();
  </script>
</body>
</html>
